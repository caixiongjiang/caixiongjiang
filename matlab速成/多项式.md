```m
第4部分：多项式

%%
%多项式
    %创建
        p = [1, 2, 3, 4];  % 系数向量，按x降幂排列，最右边是常数
        f1 = poly2str(p, 'x');  % 生成好看的字符串 f1 = x^3 + 2 x^2 + 3 x + 4，不被认可的运算式
        f2 = poly2sym(p);  % 生成可用的符号函数 f2 = x^3 + 2*x^2 + 3*x + 4
    %求值
        x = 4;
        y1 = polyval(p, x);  % 代入求值；若x1为矩阵，则对每个值单独求值
    %求根
        r = roots(p); % p同上，由系数求根，结果为根植矩阵
        p0 = poly(r);  % 由根求系数，结果为系数矩阵
        
%%
%数据插值
    %一维插值
        %yi = interp1(X, Y, xi, 'method')
        X = [-3, -1, 0, 1, 3];
        Y = [9, 1, 0, 1, 9];  % XY为已知点横纵坐标向量
        y2 = interp1(X, Y, 2);  % 差值预估在x=2的y的值，x不能超过已知范围(此处x<3)
        y2m = interp1(X, Y, 2, 'spline');  % 用spline方法(三次样条)差值预估在x=2的y的值
    %二维插值
        %zi = interp1(X, Y, Z, xi, yi, 'method')
        
%%
X = [2, 3, 9, 15, 6, 7, 4];
A = [1, 7, 2; 9, 5, 3; 8, 4 ,6];
B = [1, 7, 3; 9, 5, 3; 8, 4 ,6];
%数据统计
    %矩阵最大最小值
        y = max(X);  % 求矩阵X的最大值，min最小值
        [y, k] = max(X);  % 求最大值，k为该值的角标
        [y, k] = max(A, [], 2);  % A是矩阵，'2'时返回y每一行最大元素构成的列向量，k元素所在列；'1'时与上述相同
    %均值和中值
        y = mean(X);  % 均值
        y = median(X);  % 中值
        y = mean(A, 2);  % '2'时返回y每一行均值构成的列向量；'1'时与上述相同
        y = median(A, 2);  % '2'时返回y每一行中值构成的列向量；'1'时与上述相同
    %排序
        Y = sort(A, 1, 'ascend');  % sort(矩阵, dim, 'method')dim为1按列排序，2按行排序；ascend升序，descend降序
        [Y, I] = sort(A, 1, 'ascend');  % I保留了元素之前在A的位置
    %求和求积累加累乘
        y = sum(X);  % 求和
        y = prod(X);  % 求积
        y = cumsum(X);  % 累加
        y = cumprod(X);  % 累乘
        
%%
%*数值计算
    %最(极)值
        %多元函数在给定初值附近找最小值点
        x = fminsearch(fun, x0);
    %函数零点
        x = fzero(fun, x0);  % 在给定初值x0附近找零点


第5部分：符号函数

%%
%符号对象创建
    %sym函数
        p = sin(pi/3);
        P = sym(p, 'r');  % 用数值p创建符号常量P；'d'浮点数'f'有理分式的浮点数'e'有理数和误差'r'有理数
    %syms函数
        syms x;  % 声明符号变量
        f = 7*x^2 + 2*x+9;  % 创建符号函数
    %符号运算
        % 加减乘除外
        % '转置 ； ==相等 ； ~=不等
        % sin, cos, tan; asin, acos, atan 三角反三角
        % sinh, cosh, tanh; asinh, acosh, atanh 双曲反双曲
        % conj复数共轭；real复数实部；imag复数虚部；abs复数模；angle复数幅角
        % diag矩阵对角；triu矩阵上三角；tril矩阵下三角；inv逆矩阵；det行列式；rank秩；poly特征多项式；
        % |----expm矩阵指数函数；eig矩阵特征值和特征向量；svd奇异值分解；
    %符号对象精度转换
        digits;  % 显示当前用于计算的精度
        digits(16);  % 将计算精度改为16位，降低精度有时可以加快程序运算速度或减少空间占用
        a16 = vpa(sqrt(2));  % vpa括起的运算使sqrt(2)运算按照规定的精度执行
        a8 = vpa(sqrt(2), 8);  % 在vpa内控制精度，离开这一步精度恢复
        
%%
%符号多项式函数运算
    %*符号表达形式与相互转化
        %多项式展开整理
            g = expand(f);  % 展开
            h = collect(g);  % 整理(默认按x整理)
            h1 = collect(f, x);  % 按x整理（降幂排列）
        %因式分解展开质因数
            fac = factor(h);  % 因式分解
            factor(12);  % 对12分解质因数
    %符号多项式向量形式与计算
        syms a b c;
        n = [a, b, c];
        roots(n);  % 求符号多项式ax^2+bx+c的根
        n = [1, 2, 3];
        roots(n);  % 求符号多项式带入a=1, b=2, c=3的根
    %*反函数
        fi = finverse(f, x);  % 对f中的变量x求反函数
        
%%
%符号微积分
    %函数的极限和级数运算
        % 常量a，b
        %极限
            limit(f, x, 4);  % 求f(x), x->4
            limit(f, 4);  % 默认变量->4
            limit(f);  % 默认变量->0
            limit(f, x, 4, 'right');  % 求f(x), x->4+, 'left' x->4-
        %*基本级数运算
            %求和
                symsum(s, x, 3, 5);  % 计算表达式s变量x从3到5的级数和，或symsum(s, x, [a b])或symsum(s, x, [a;b])
                symsum(s, 3, 5);  % 计算s默认变量从3到5的级数和
                symsum(s);  % 计算s默认变量从0到n-1的级数和
            %一维泰勒展开
                taylor(f, x, 4);  % f在x=4处展开为五阶泰勒级数
                taylor(f, x);  % f在x=0处展开为五阶泰勒级数
                taylor(f);  % f在默认变量=0处展开为五阶泰勒级数
    %符号微分
        %单变量求导（单变量偏导）
            n = 1;  % 常量n
            fn = diff(f, x, n);  % f对x的n阶导
            f1 = diff(f, x);  % f对x的1阶导
            diff(f, n);  % f对默认变量的n阶导
            diff(f);  % 默认变量1阶导
        %多元偏导
            fxy = diff(f, x, y);  % 先求x偏导，再求y偏导
            fxyz = diff(f, x, y, z);  % 先求x偏导，再求y偏导,再求z偏导
    %符号积分
        %积分命令
            int(f, x, 1, 2);  % 函数f变量x在1~2区间定积分
            int(f, 1, 2);  % 函数f默认变量在ab区间定积分
            int(f, x);  % 函数f变量x不定积分
            int(f);  % 函数f默认变量不定积分
            % 傅里叶，拉普拉斯，Z变换
            
%%
%*符号方程求解
    %符号代数方程
        %一元方程
            eqn1 = a*x==b;
            S = solve(eqn1);  % 返回eqn符号解
        %多元方程组
            eqn21 = x-y==a;
            eqn22 = 2*x+y==b;
            [Sx, Sy] = solve(eqn21, eqn22, x, y);  % [Svar1,...SvarN]=solve(eqn1,...eqnM, var1,...varN),MN不一定相等
            [Sxn, Syn] = solve(eqn21, eqn22, x, y, 'ReturnCondition', true);  % 加上参数ReturnCondition可返回通解及解的条件
            % 其他参数(参数加上true生效)
                % IgnoreProperty，忽略变量定义时一些假设
                % IgnoreAnalyticConstraints，忽略分析限制；
                % MaxDegree，大于3解显性解；
                % PrincipleValue，仅主值
                % Real，仅实数解
        %非线性fsolve
            X = fsolve(fun, X0, optimset(option));  % fun函数.m文件名；X0求根初值；option选项如('Display','off')不显示中间结果等
```