## 编号383：超级次方

你的任务是计算 ab 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。

 

示例 1：
```
输入：a = 2, b = [3]
输出：8
```
示例 2：
```
输入：a = 2, b = [1,0]
输出：1024
```
示例 3：
```
输入：a = 1, b = [4,3,3,8,5,2]
输出：1
```
示例 4：
```
输入：a = 2147483647, b = [2,0,0]
输出：1198 
```
提示：

* 1 <= a <= 231 - 1
* 1 <= b.length <= 2000
* 0 <= b[i] <= 9
* b 不含前导 0

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/super-pow
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

---
## 思路

注意点：
* 1.b的数组长度最大可以达到2000，所以不能用内置的pow函数求b的值，会超出最大的数的表示范围。
* 2.b数组必须逆序遍历

### 方法：快速幂

根据题意，要我们求得的是mod1337 的值，其中 b 是以数组形式给出。

刚一看是一道快速幂的题目（事实上也确实可以使用快速幂，但不是必须），但由于 b 是数组形式，因此我们还需要对其进行分解。

我们每次只需要计算 bb 数组的最后一位作为次方的值即可将问题规模缩小。

上述公式可能不好直接理解，举个🌰，设我们的 aa 为 9999，要计算的 bb 数组所代表的数值为K=2345，那么其计算过程可以分解为：
```
0. a^K =99^2345
1. 99^2345 = 99^(234*10+5)
2. 99^(234*10+5) = 99^(234*10) * 99^5
3. 99^(234*10) * 99^5 = (99^(234))^10 * 99^5
···
```
可见，真正涉及计算次方的操作，所用到的次方都是一个 1010 以内的数字，因此并非一定要使用快速幂。



整体代码如下：
```c++
class Solution {
    const int MOD = 1337;

    int pow(int x, int n) {
        int res = 1;
        while (n) {
            if (n % 2) {
                res = (long) res * x % MOD;
            }
            x = (long) x * x % MOD;
            n /= 2;
        }
        return res;
    }

public:
    int superPow(int a, vector<int> &b) {
        int ans = 1;
        for (int i = b.size() - 1; i >= 0; --i) {
            ans = (long) ans * pow(a, b[i]) % MOD;
            a = pow(a, 10);
        }
        return ans;
    }
};
```