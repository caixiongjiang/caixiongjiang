## 编号629：K个逆序对数组

给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的个数。

逆序对的定义如下：对于数组的第i个和第 j个元素，如果满i < j且 a[i] > a[j]，则其为一个逆序对；否则不是。

由于答案可能很大，只需要返回 答案 mod 109 + 7 的值。

示例 1:
```
输入: n = 3, k = 0
输出: 1
解释: 
只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。
```
示例 2:
```
输入: n = 3, k = 1
输出: 2
解释: 
数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。
```
说明:

</br>1. n 的范围是 [1, 1000] 并且 k 的范围是 [0, 1000]。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/k-inverse-pairs-array
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

---
## 思路

方法一：动态规划
**思路与算法**

我们可以用动态规划的方法来解决本题。

设f[i][j] 表示我们使用数字 1, 2,⋯,i 的排列构成长度为 i 的数组，并且恰好包含 j 个逆序对的方案数。在进行状态转移时，我们可以考虑第 i 个元素选取了 1, 2,⋯,i 中的哪个数字。

假设我们选取了数字 k，那么数组的前 i−1 个元素由1,⋯,k−1 以及k+1,⋯,i 的某个排列构成。数组中的逆序对的个数可以看成如下的两部分之和：

* 数字 kk 与前 i-1i−1 个元素产生的逆序对的个数；

* 前 i-1i−1 个元素「内部」产生的逆序对个数。

对于第一部分而言，我们可以求出：数字 k 会贡献 i−k 个逆序对，即k+1,⋯,i 与 k 分别产生一个逆序对。

对于第二部分而言，我们希望它能够有j−(i−k) 个逆序对，这样才能一共有 j 个逆序对。由于我们关心的是前i−1 个元素「内部」产生的逆序对个数，而逆序对只和元素的「相对大小」有关，因此我们可以：

* 1,⋯,k−1 这些元素保持不变；

* k+1,⋯,i 这些元素均减少 1，变成k,⋯,i−1。

使得前i−1 个元素中，任意两个元素的相对大小都不发生变化。此时，我们的目标变成了「对于 1,2,⋯,i−1，希望它能够有j−(i−k) 个逆序对」，这就是动态规划中的子任务f[i−1][j−(i−k)]。

因此，我们就可以通过枚举 kk 得到状态转移方程：
$$
f[i][j] = \sum_{k=1}^i f[i-1][j-(i-k)] = \sum_{k=0}^{i-1} f[i-1][j-k]
$$
边界条件为：

f[0][0] = 1，即不用任何数字可以构成一个空数组，它包含 0 个逆序对；

f[i][j < 0] = 0，由于逆序对的数量一定是非负整数，因此所有 j < 0的状态的值都为0。我们不需要显式地存储这些状态，只需要在进行状态转移遇到这样的项时，注意特殊判断即可。

最终的答案即为f[n][k]。

**优化**

上述动态规划的状态数量为O(nk)，而求出每一个 f[i][j] 需要 O(n) 的时间复杂度，因此总时间复杂度为 O(n^2k)，会超出时间限制，我们必须要进行优化。

我们考虑 f[i][j-1]f[i][j−1] 和 f[i][j]f[i][j] 的状态转移方程：

$$\left\{ \begin{aligned} & f[i][j-1] && = && \sum_{k=0}^{i-1} f[i-1][j-1-k] \\ & f[i][j] && = && \sum_{k=0}^{i-1} f[i-1][j-k] \end{aligned} \right.
$$
 

可以得到从f[i][j−1]到f[i][j] 的递推式：


f[i][j]=f[i][j−1]−f[i−1][j−i]+f[i−1][j]

这样我们就可以在 O(1) 的时间计算出每个f[i][j]，总时间复杂度降低为O(nk)。

此外，由于f[i][j]只会从第f[i−1][..]和f[i][..]转移而来，因此我们可以对动态规划使用的空间进行优化，即使用两个一维数组交替地进行状态转移，空间复杂度从O(nk)降低为O(k)。

整体代码如下：
```c++
class Solution {
private:
    static constexpr int mod = 1000000007;

public:
    int kInversePairs(int n, int k) {
        vector<vector<int>> f(2, vector<int>(k + 1));
        f[0][0] = 1;
        for (int i = 1; i <= n; ++i) {
            for (int j = 0; j <= k; ++j) {
                int cur = i & 1, prev = cur ^ 1;
                f[cur][j] = (j - 1 >= 0 ? f[cur][j - 1] : 0) - (j - i >= 0 ? f[prev][j - i] : 0) + f[prev][j];
                if (f[cur][j] >= mod) {
                    f[cur][j] -= mod;
                }
                else if (f[cur][j] < 0) {
                    f[cur][j] += mod;
                }
            }
        }
        return f[n & 1][k];
    }
};

```