## 编号629：K个逆序对数组

给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的个数。

逆序对的定义如下：对于数组的第i个和第 j个元素，如果满i < j且 a[i] > a[j]，则其为一个逆序对；否则不是。

由于答案可能很大，只需要返回 答案 mod 109 + 7 的值。

示例 1:
```
输入: n = 3, k = 0
输出: 1
解释: 
只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。
```
示例 2:
```
输入: n = 3, k = 1
输出: 2
解释: 
数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。
```
说明:

</br>1. n 的范围是 [1, 1000] 并且 k 的范围是 [0, 1000]。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/k-inverse-pairs-array
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

---
## 思路

不妨按照11到NN的顺序依次添加数字。在添加数字ii的时候，最多可以形成i-1i−1个新的逆序对（将ii放在最前面），最少则是不形成新的逆序对（将ii放在最后面）。

令dp[i][j]表示添加到数字i时，一共形成j个逆序对的方法数，由上面的分析，不难看出
$$
dp[i][j]=\sum_{k=0}^{i-1} dp[i-1][j-k]
$$
直接按照这一转移方程进行计算的复杂度将达到O(N^2 * K)，无法在时限内完成。但注意到这里的求和部分是连续项求和，并且，在计算dp[i]时，所有的dp[i−1]应该都已经计算完成，那么我们就可以在计算完dp[i−1]后，求出其对应的前缀和，从而就能够以O(1)的时间计算出任意的dp[i][j]。

进一步的，因为dp[i]dp[i]完全取决于dp[i-1]dp[i−1]，我们可以将动态规划的数组压缩为一维。

* 时间复杂度O(NK)
* 空间复杂度O(K)

整体代码如下：
```c++
const int MOD = 1e9 + 7;
const int MAXN = 1005;

int dp[MAXN]{}, pre[MAXN]{};

class Solution {
public:
    int kInversePairs(int n, int k) {
        memset(pre, 0, sizeof(pre));
        for (int i = 1; i <= n; ++i) {
            dp[1] = 1;

            for (int j = 2; j <= k + 1; ++j) {
                dp[j] = (pre[j] - pre[max(0, j - i)] + MOD) % MOD;
            }

            for (int j = 1; j <= k + 1; ++j) {
                pre[j] = (pre[j - 1] + dp[j]) % MOD;
            }
        }

        return dp[k + 1];
    }
};
```