## 编号423：从英文中重建数字

给你一个字符串 s ，其中包含字母顺序打乱的用英文单词表示的若干数字（0-9）。按 升序 返回原始的数字。

 

示例 1：
```
输入：s = "owoztneoer"
输出："012"
```
示例 2：
```
输入：s = "fviefuro"
输出："45" 
```
提示：

* 1 <= s.length <= 105
* s[i] 为 ["e","g","f","i","h","o","n","s","r","u","t","w","v","x","z"] 这些字符之一
* s 保证是一个符合题目要求的字符串

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/reconstruct-original-digits-from-english
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

---
## 思路

首先我们可以统计每个字母分别在哪些数字中出现：
```
字母	数字
e	0 1 3 5 7 8 9
f	4 5
g	8
h	3 8
i	5 6 8 9
n	1 7 9
o	0 1 2 4
r	0 3 4
s	6 7
t	2 3 8
u	4
v	5 7
w	2
x	6
z	0
```
可以发现,z, w, u, x, g 都只在一个数字中，即0,2,4,6,8 中出现。因此我们可以使用一个哈希表统计每个字母出现的次数，那么z, w, u, x, g 出现的次数，即分别为0,2,4,6,8 出现的次数。

随后我们可以注意那些只在两个数字中出现的字符：

* h 只在3,8中出现。由于我们已经知道了8出现的次数，因此可以计算出3出现的次数。

* f 只在4,5中出现。由于我们已经知道了4出现的次数，因此可以计算出5出现的次数。

* s 只在6,7中出现。由于我们已经知道了6出现的次数，因此可以计算出7出现的次数。

此时，我们还剩下1和9的出现次数没有求出：

* o 只在0,1,2,4 中出现，由于我们已经知道了0,2,4 出现的次数，因此可以计算出1出现的次数。

**最后的9就可以通过n, i, e 中的任一字符计算得到了。这里推荐使用i进行计算，因为n在9中出现了2次，e 在 3 中出现了2次，容易在计算中遗漏。**

当我们统计完每个数字出现的次数后，我们按照升序将它们进行拼接即可。



整体代码如下：
```c++
class Solution {
public:
    string originalDigits(string s) {
        unordered_map<char, int> map;
        for(char ch : s){
            map[ch]++;
        }

        vector<int> cnt(10);
        cnt[0] = map['z'];
        cnt[2] = map['w'];
        cnt[4] = map['u'];
        cnt[6] = map['x'];
        cnt[8] = map['g'];

        cnt[3] = map['h'] - cnt[8];
        cnt[5] = map['f'] - cnt[4];
        cnt[7] = map['s'] - cnt[6];
        cnt[1] = map['o'] - cnt[0] - cnt[2] - cnt[4];
        cnt[9] = map['i'] - cnt[5] - cnt[6] - cnt[8];

        string ans;
        for(int i = 0; i < 10; i++){
            for(int j = 0; j < cnt[i]; j++){
                ans += char(i + '0');
            }
        }
        return ans;
    }
};
```