## 编号2048：下一个更大的数值平均数(AC)

如果整数  x 满足：对于每个数位 d ，这个数位 恰好 在 x 中出现 d 次。那么整数 x 就是一个 数值平衡数 。

给你一个整数 n ，请你返回 严格大于 n 的 最小数值平衡数 。

 

示例 1：
```
输入：n = 1
输出：22
解释：
22 是一个数值平衡数，因为：
- 数字 2 出现 2 次 
这也是严格大于 1 的最小数值平衡数。
```
示例 2：
```
输入：n = 1000
输出：1333
解释：
1333 是一个数值平衡数，因为：
- 数字 1 出现 1 次。
- 数字 3 出现 3 次。 
这也是严格大于 1000 的最小数值平衡数。
注意，1022 不能作为本输入的答案，因为数字 0 的出现次数超过了 0 。
```
示例 3：
```
输入：n = 3000
输出：3133
解释：
3133 是一个数值平衡数，因为：
- 数字 1 出现 1 次。
- 数字 3 出现 3 次。 
这也是严格大于 3000 的最小数值平衡数。 
```
提示：

* 0 <= n <= 106

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/next-greater-numerically-balanced-number
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

---
## 思路

首先看到这道题目，就想到了hash数组，求出每个数位的值的个数并计入hash table，判断是不是数值平衡数。

自己AC的版本，代码中重复的逻辑比较多，后面整理了一个比较简洁的版本：
```c++
class Solution {
private:
    //这里的nums数组类似于一个hash数组,下标i代表n的每一个数位的数字，nums[i]代表这个数字出现的次数
    int nums[10];   
    bool check(int n){
        memset(nums, 0, sizeof(nums));//调用函数初始化作用类似于a[]={0};
        while(n != 0){
            nums[n % 10]++;
            n = n / 10;
        }
        for(int i = 0; i < 10; i++){
            //判断条件
            if(nums[i] != 0 && nums[i] != i) return false;
        }
        return true;
    }
public:
    int nextBeautifulNumber(int n) {
        while(!check(++n)); //这里必须是++n,先对n做加1的操作，再检查是否为数值平衡数
        return n;
    }
};
```