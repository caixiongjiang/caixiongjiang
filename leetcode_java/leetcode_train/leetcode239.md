## 编号239：滑动窗口最大值(单调队列经典应用)

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

 

示例 1：
```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```
示例 2：
```
输入：nums = [1], k = 1
输出：[1]
```
示例 3：
```
输入：nums = [1,-1], k = 1
输出：[1,-1]
```
示例 4：
```
输入：nums = [9,11], k = 2
输出：[11]
```
示例 5：
```
输入：nums = [4,-2], k = 2
输出：[4] 
```
提示：

1 <= nums.length <= 105
-104 <= nums[i] <= 104
1 <= k <= nums.length

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/sliding-window-maximum
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

---
## 思路

暴力方法，遍历一遍的过程中每次从窗口中在找到最大的数值，这样很明显是O(n * k)的算法。

有的同学可能会想用一个大顶堆（优先级队列）来存放这个窗口里的k个数字，这样就可以知道最大的最大值是多少了， ***但是问题是这个窗口是移动的，而大顶堆每次只能弹出最大值，我们无法移除其他数值，这样就造成大顶堆维护的不是滑动窗口里面的数值了。所以不能用大顶堆。***

此时我们需要一个队列，这个队列呢，放进去窗口里的元素，然后随着窗口的移动，队列也一进一出，每次移动之后，队列告诉我们里面的最大值是什么。

这个队列应该长这个样子：
```java
class MyQueue {
public:
    void pop(int value) {
    }
    void push(int value) {
    }
    int front() {
        return que.front();
    }
};
```
每次窗口移动的时候，调用que.pop(滑动窗口中移除元素的数值)，que.push(滑动窗口添加元素的数值)，然后que.front()就返回我们要的最大值。
</br>分析一下，队列里的元素一定是要排序的，而且要最大值放在出队口，要不然怎么知道最大值呢。

但如果把窗口里的元素都放进队列里，窗口移动的时候，队列需要弹出元素。

那么问题来了，已经排序之后的队列 怎么能把窗口要移除的元素（这个元素可不一定是最大值）弹出呢。

***其实队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队里里的元素数值是由大到小的。***

那么这个维护元素单调递减的队列就叫做***单调队列，即单调递减或单调递增的队列***。
实现的单调队列不是对窗口里面的数进行排序，如果排序的话，那和优先级队列没有区别。
![avater](https://camo.githubusercontent.com/b510f38be30a2445ec0036ff122a248e467cacd9190fe36f235f145152bfdf8a/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f3233392e2545362542422539312545352538412541382545372541412539372545352538462541332545362539432538302545352541342541372545352538302542432e676966)
</br>对于窗口里的元素{2, 3, 5, 1 ,4}，单调队列里只维护{5, 4} 就够了，保持单调队列里单调递减，此时队列出口元素就是窗口里最大元素。

此时大家应该怀疑单调队列里维护着{5, 4} 怎么配合窗口经行滑动呢？

设计单调队列的时候，pop，和push操作要保持如下规则：

* pop(value)：<span style="color:green">如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作</span>
* push(value):<span style="color:green">如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止</span>
</br>保持如上规则，每次窗口移动的时候，只要问que.front()就可以返回当前窗口的最大值。

以题目示例为例，输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3，动画如下：

![avater](https://camo.githubusercontent.com/ea3de7a4766fab1034270d9c17d290a7395c3c9ae09649d49d511d7923253c64/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f3233392e2545362542422539312545352538412541382545372541412539372545352538462541332545362539432538302545352541342541372545352538302542432d322e676966)

java代码如下：
```java
//自定义数组(单调队列)
class MyQueue{
    Deque<Integer> deque =new LinkedList<>();
    //弹出元素时，比较当前要弹出的数值是否等于队列出口的数值，如果相等则弹出
    //同时判断队列当前是否为空
    void poll(int val){
        if(!deque.isEmpty() && val==deque.peek()){
            deque.poll();//弹出
        }
    }
    //添加元素时，如果要添加的元素大于入口处的元素，就将入口元素弹出
    //保证队列元素单调递减
    //比如此时队列元素3,1，2将要入队，比1大，所以1弹出，此时队列：3,2
    void add(int val){
        while(!deque.isEmpty() && val>deque.getLast()){
            deque.removeLast();
        }
        deque.add(val);
    }
    //队列队顶元素始终为最大值
    int peek(){
        return deque.peek();
    }
}

class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if(nums.length==1){
            return nums;
        }
        int len=nums.length-k+1;//输出结果数组的长度
        int[] res=new int[len];
        int num=0;
        //自定义队列
        MyQueue myQueue=new MyQueue();
        //先将k个元素放入队列
        for(int i=0;i<k;i++){
            myQueue.add(nums[i]);
        }
        res[num++]=myQueue.peek();//出队口即为最大元素
        //将剩余元素放入单调队列进行维护
        for(int i=k;i<nums.length;i++){
            //滑动窗口移除最前面的元素，并判断是否放入res数组
            myQueue.poll(nums[i-k]);
            //滑动窗口加入最后面的元素
            myQueue.add(nums[i]);
            //记录最新的最大值
            res[num++]=myQueue.peek();
        }
    return res;
    }
}
```