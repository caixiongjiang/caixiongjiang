## 二叉树的种类

在我们解题过程中二叉树有两种主要的形式：**满二叉树**和**完全二叉树**。
</br>要注意完全二叉树的判断，举一个典型的例子如题：
![avater](https://camo.githubusercontent.com/1018be638b7b2e45151250bb3327673b1dad76b102ac7b18319a213ef9010845/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303932303232313633383930332e706e67)

## 二叉搜索树
前面介绍的树，都没有数值的，而***二叉搜索树是有数值的***了，二叉搜索树是一个有序树。
* 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
* 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
* 它的左、右子树也分别为二叉排序树

## 平衡二叉搜索树
平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
</br>如图：
![avater](https://camo.githubusercontent.com/43cdb4219b8917c8af61a234d92a01b601ee224efd08255d4f6c97c1d4c67c57/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303830363139303531313936372e706e67)

## 二叉树的存储方式
***二叉树可以链式存储，也可以顺序存储。***

那么链式存储方式就用索引， 顺序存储的方式就是用数组。

顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过索引把分布在散落在各个地址的节点串联一起。

链式存储如图：
![avater](https://camo.githubusercontent.com/a7a024e16590d7acba3010c21b18bd5f326dc4b0a1cfaf58b5f441ba77f8b4f2/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f323032303039323031393535343631382e706e67)

链式存储是大家很熟悉的一种方式，那么我们来看看如何顺序存储呢？

其实就是用数组来存储二叉树，顺序存储的方式如图：
![avater](https://camo.githubusercontent.com/1dd58317f3f36c2a649fcac642e19529d71f082df94511d1d85a03d229482e10/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303932303230303432393435322e706e67)

数组存储的二叉树的遍历：
</br>***如果父节点的数组下表是i，那么它的左孩子就是i * 2 + 1，右孩子就是 i * 2 + 2。***

## 二叉树的遍历方式
二叉树主要有两种遍历方式：
* 1.深度优先遍历：先往深走，遇到叶子节点再往回走。
* 2.广度优先遍历：一层一层的去遍历。
</br>**这两种遍历是图论中最基本的两种遍历方式**，后面在介绍图论的时候 还会介绍到。

那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：

### 深度优先遍历
* 前序遍历（递归法，迭代法）
* 中序遍历（递归法，迭代法）
* 后序遍历（递归法，迭代法）
### 广度优先遍历
* 层次遍历（迭代法）

看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式

* 前序遍历：中左右
* 中序遍历：左中右
* 后序遍历：左右中
</br>如下图:
![avater](https://camo.githubusercontent.com/2d9958dba205749538b8183bdb3c848a14093a18e70d75d2393efa47ee514520/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303830363139313130393839362e706e67)

## 二叉树的定义
### 链式存储的二叉树定义
c++代码如下：
```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```
java代码如下：
```java
public class TreeNode {
     int val;
     TreeNode left;
     TreeNode right;
     TreeNode() {}
     TreeNode(int val) { this.val = val; }
     TreeNode(int val, TreeNode left, TreeNode right) {
         this.val = val;
         this.left = left;
         this.right = right;
         }
    }
```