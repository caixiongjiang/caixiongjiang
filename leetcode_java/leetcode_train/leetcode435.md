## 编号435：无重叠区间

给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

注意:

1.可以认为区间的终点总是大于它的起点。
</br>2.区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。

示例 1:
```
输入: [ [1,2], [2,3], [3,4], [1,3] ]

输出: 1

解释: 移除 [1,3] 后，剩下的区间没有重叠。
```
示例 2:
```
输入: [ [1,2], [1,2], [1,2] ]

输出: 2

解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
```
示例 3:
```
输入: [ [1,2], [2,3] ]

输出: 0

解释: 你不需要移除任何区间，因为它们已经是无重叠的了。
```
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/non-overlapping-intervals
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

---
## 思路
这题感觉要排序，但是究竟是按照右边界排序，还是按照左边界排序呢？

这其实是一个难点！

**按照右边界排序，就要从左向右遍历，因为右边界越小越好，只要右边界越小，留给下一个区间的空间就越大**，所以从左向右遍历，优先选右边界小的。

**按照左边界排序，就要从右向左遍历，因为左边界数值越大越好（越靠右）**，这样就给前一个区间的空间就越大，所以可以从右向左遍历。

如果按照左边界排序，还从左向右遍历的话，其实也可以，逻辑会有所不同。

题目只是要求移除区间的个数，没有必要去真实的模拟删除区间！

我按照右边界排序，从左向右记录非交叉区间的个数。<span style="color:green">最后用区间总数减去非交叉区间的个数就是需要移除的区间个数了。</span>

此时问题就是要求非交叉区间的最大个数。

右边界排序之后，局部最优：优先选右边界小的区间，所以从左向右遍历，留给下一个区间的空间大一些，从而尽量避免交叉。全局最优：选取最多的非交叉区间。

局部最优推出全局最优，试试贪心！

这里记录非交叉区间的个数还是有技巧的，如图：
![avater](https://camo.githubusercontent.com/9bb134241b2872c809006a5597e1f247dd219270ac581dc4437417e6bf6bd549/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230313232313230313535333631382e706e67)
区间，1，2，3，4，5，6都按照右边界排好序。

每次取非交叉区间的时候，都是可右边界最小的来做分割点（这样留给下一个区间的空间就越大），所以第一条分割线就是区间1结束的位置。

接下来就是找大于区间1结束位置的区间，<span style="color:yellow">**是从区间4开始**</span>。那为什么不从区间5开始？别忘了是**按照右边界排序**的了。

区间4结束之后，在找到区间6，所以一共记录非交叉区间的个数是三个。

总共区间个数为6，减去非交叉区间的个数3。移除区间的最小数量就是3。

整体代码如下：
```java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        if (intervals.length == 0) {
            return 0;
        }
        
        Arrays.sort(intervals, new Comparator<int[]>() {
            //按照右边界排序
            public int compare(int[] interval1, int[] interval2) {
                return interval1[1] - interval2[1];
            }
        });

        int n = intervals.length;
        int right = intervals[0][1];
        int ans = 1;
        for (int i = 1; i < n; i++) {
            if (intervals[i][0] >= right) {
                ans++;
                right = intervals[i][1];
            }
        }
        return n - ans;
    }
}
```
