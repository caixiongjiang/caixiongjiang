## 编号96：不同的二叉搜索树
给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的**二叉搜索树**有多少种？返回满足题意的二叉搜索树的种数。

 

示例 1：
![avater](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)

```
输入：n = 3
输出：5
```
示例 2：
```
输入：n = 1
输出：1
```

提示：

* 1 <= n <= 19

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/unique-binary-search-trees
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

---
## 思路

![avater](https://camo.githubusercontent.com/cc55e4084bb2f88efa82abab0a2d9f810e79acbf93540815c229361cebf03fb2/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303130373039333130363336372e706e67)

n为1的时候有一棵树，n为2的时候有两棵树，很直观。

![avater](https://camo.githubusercontent.com/bf3fdc435d1771942205a97a1f754dc39498dc2cce5886a429b2f113028e70b4/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303130373039333132393838392e706e67)

当n为3时，有5个二叉搜索树。

**当1为头结点的时候，其右子树有两个节点，这两个节点的布局和n = 2的时候两棵树的布局是一样的。**

**当3为头结点的时候，其左子树有两个节点，这两个节点的布局和n = 2的时候两棵树的布局也是一样的。**

也就是说可以通过dp[1]和dp[2]来推导dp[3]。

**dp[3]就是元素为1头结点的二叉搜索树的数量 + 元素2为头结点的而叉搜索树的数量 + 元素3为头结点的二叉搜索树的数量

元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量

元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量

元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量

有2个元素的搜索树数量就是dp[2]。

有1个元素的搜索树数量就是dp[1]。

有0个元素的搜索树数量就是dp[0]。

所以dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]

如图所示：
![avater](https://camo.githubusercontent.com/5df19b9d8c1706667c7e336a21349441cc4a248bdb1dc74dca4eb333a426858f/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303130373039333232363234312e706e67)

## 动态规划5步曲

1.确定dp数组（dp table）以及下标的含义

dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]。

也可以理解是i的不同元素节点组成的二叉搜索树的个数为dp[i] ，都是一样的。

以下分析如果想不清楚，就来回想一下dp[i]的定义

2.确定递推公式

在上面的分析中，其实已经看出其递推关系， dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]

j相当于是头结点的元素，从1遍历到i为止。

所以递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量

3,。dp数组如何初始化

初始化，只需要初始化dp[0]就可以了，推导的基础，都是dp[0]。

那么dp[0]应该是多少呢？

从定义上来讲，空节点也是一颗二叉树，也是一颗二叉搜索树，这是可以说得通的。

从递归公式上来讲，dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] 中以j为头结点左子树节点数量为0，也需要dp[以j为头结点左子树节点数量] = 1， 否则乘法的结果就都变成0了。

所以初始化dp[0] = 1

4.确定遍历顺序

首先一定是遍历节点数，从递归公式：dp[i] += dp[j - 1] * dp[i - j]可以看出，节点数为i的状态是依靠 i之前节点数的状态。

那么遍历i里面每一个数作为头结点的状态，用j来遍历。

代码如下：
```
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= i; j++) {
        dp[i] += dp[j - 1] * dp[i - j];
    }
}
```
5.举例推导dp数组

n为5时候的dp数组状态如图：

![avater](https://camo.githubusercontent.com/9804c8e1f798fa49f23a862197346a021b620ee1a33f52c4552cb9f538fc3fb4/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303130373039333235333938372e706e67)

整体代码如下：
```java
class Solution {
    public int numTrees(int n) {
        //初始化dp数组
        int[] dp = new int[n + 1];
        dp[0] = 1;//为了后续结果不为0
        dp[1] = 1;
        for(int i = 2; i <= n; i++){
            for(int j = 1; j <= i; j++){
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
}
```