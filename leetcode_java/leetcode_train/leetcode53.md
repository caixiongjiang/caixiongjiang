## 编号53：最大子序和
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

 

示例 1：
```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```
示例 2：
```
输入：nums = [1]
输出：1
```
示例 3：
```
输入：nums = [0]
输出：0
```
示例 4：
```
输入：nums = [-1]
输出：-1
```
示例 5：
```
输入：nums = [-100000]
输出：-100000 
```
提示：

* 1 <= nums.length <= 3 * 104
* -105 <= nums[i] <= 105
 

进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/maximum-subarray
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

---
## 思路
暴力解法的时间复杂度是O(n^2)，不作讨论

## 贪心解法
**贪心贪的是哪里呢？**

如果 -2 1 在一起，计算起点的时候，一定是从1开始计算，因为负数只会拉低总和，这就是贪心贪的地方！

局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。

全局最优：选取最大“连续和”

**局部最优的情况下，并记录最大的“连续和”，可以推出全局最优。**

从代码角度上来讲：遍历nums，从头开始用count累积，如果count一旦加上nums[i]变为负数，那么就应该从nums[i+1]开始从0累积count了，因为已经变为负数的count，只会拖累总和。

**这相当于是暴力解法中的不断调整最大子序和区间的起始位置。**

**那有同学问了，区间终止位置不用调整么？ 如何才能得到最大“连续和”呢？**

区间的终止位置，其实就是如果count取到最大值了，及时记录下来了。例如如下代码：
```java
if(count > result) result = count;
```
这样相当于是用result记录最大子序和区间和（变相的算是调整了终止位置）。

如动画所示：
![avater](https://camo.githubusercontent.com/a6eb977f19950bb2c56d68964d100c17ac464b16c022cf803c94486da5281f3a/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f676966732f35332e2545362539432538302545352541342541372545352541442539302545352542412538462545352539322538432e676966)
红色的起始位置就是贪心每次取count为正数的时候，开始一个区间的统计。

整体代码如下：
```java
class Solution {
    public int maxSubArray(int[] nums) {
        if(nums.length == 1){
            return nums[0];
        }
        int maxSum = Integer.MIN_VALUE;
        int sum = 0;
        for(int i = 0; i < nums.length; i++){
            sum += nums[i];
            maxSum = Math.max(sum, maxSum);//取区间累计的最大值（相当于不断确定最大子序终止位置）
            if(sum < 0){
                sum = 0;//小于0直接重新开始计算局部和
            }
        }
        return maxSum;
    }
}
```