## 关于并查集（针对leetcode684讲解）

在一棵树中，边的数量比节点的数量少1。如果一棵树有n个节点，则这棵树有n−1条边。这道题中的图在树的基础上多了一条附加的边，因此边的数量也是n。

树是一个连通且无环的无向图，在树中多了一条附加的边之后就会出现环，因此附加的边即为导致环出现的边。

可以通过并查集寻找附加的边。**初始时，每个节点都属于不同的连通分量。遍历每一条边，判断这条边连接的两个顶点是否属于相同的连通分量。**

* 如果两个顶点属于不同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间不连通，因此当前的边不会导致环出现，合并这两个顶点的连通分量。

* 如果两个顶点属于相同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间已经连通，因此当前的边导致环出现，为附加的边，将当前的边作为答案返回。

### 先明确几个概念
* 1.集合树：所有节点以代表节点为父节点构成的多叉树
* 2.节点的代表节点：可以理解为节点的父节点，从当前节点出发，可以向上找到的第一个节点
* 3.集合的代表节点：可以理解为根节点，意味着该集合内所有节点向上走，最终都能到达的节点

来个图帮助理解

![avater](https://pic.leetcode-cn.com/a01e4fa1fbb1513961b81ff3ea983a028b3c120a39d202527e7c9278e88cffa5-image.png)

上图中是一棵集合树，树中有1-6总计6个节点

整个集合的代表节点是1

4节点的代表节点是3，6节点的代表节点是1

无论沿着哪个节点向上走，最终都会达到集合代表节点的1节点

然后具体到这个题上：

我们以这个边集合为例子[[1,2], [3,4], [3,2], [1,4], [1,5]]

### 一、首先，对于边集合edges的每个元素，我们将其看作两个节点集合
比如边[2, 3],我们将其看作节点集合2，和节点集合3

### 二、在没有添加边的时候，各个节点集合独立，我们需要初始化各个节点集合的代表节点为其自身
所以，我们先初始化一个容器vector，使得vector[i]=i

这里两个i意思不同，作为索引的i是指当前节点，作为值的i是指当前节点所在集合的代表节点

比如vector[2] = 2，意味着2这个节点所在集合的代表节点就是2，没有添加边的情况下，所有节点单独成集合，自身就是代表节点

初始化后，集合图如下图所示：

![avater](https://pic.leetcode-cn.com/df3fcfb47ac68f45aaf3d80834e8044a91e6a42e63baa60be521839083338f9b-image.png)

### 三、然后我们开始遍历边集合，将边转化为集合的关系
这里有一点很重要：边[a,b]意味着a所在集合可以和b所在集合合并。
</br>合并方法很多，这里我们简单地将a集合的代表节点戳到b集合的代表节点上
</br>这意味着，将b集合代表节点作为合并后大集合的代表节点
</br>对于一个集合的代表节点s，一定有s->s，意思是s如果是代表节点，那么它本身不存在代表节点
</br>假设我们的读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]]
</br>初始化vector[0, 1, 2, 3, 4, 5]
</br>对应的index [0, 1, 2, 3, 4, 5]
##########################################################################

#### 1.读取[1,2]：
读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]]
</br>当前vector[0, 1, 2, 3, 4, 5]
</br>当前index [0, 1, 2, 3, 4, 5]
</br>原本1->1，2->2，
</br>由1节点出发，vector[1]=1, 找到1所在集合的代表节点1
</br>由2节点出发，vector[2]=2, 找到2所在集合的代表节点2
</br>于是，将1的代表置为2，vector[1]=2, vector[2]=2
</br>对应的vector[0, 2, 2, 3, 4, 5]
</br>对应的index [0, 1, 2, 3, 4, 5]
</br>原集合变为下图：

![avater](https://pic.leetcode-cn.com/c95f25c4df2dce2f872fdc076bc0c8168c3ad241b8bd18638da68112e013c908-image.png)

##########################################################################

#### 2.读取[3, 4]
读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]]
</br>当前vector[0, 2, 2, 3, 4, 5]
</br>当前index [0, 1, 2, 3, 4, 5]
</br>同理，将3所在集合的的代表节点3的代表节点置为4
</br>对应的vector[0, 2, 2, 4, 4, 5]
</br>对应的index [0, 1, 2, 3, 4, 5]
</br>集合变化如下图：

![avater](https://pic.leetcode-cn.com/52d1a28110784aee9b145cd725834a51a4e9e7e87e5ec5a2ba2c83f42c44dc79-image.png)

##########################################################################

#### 3.读取[3, 2]
读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]]
当前vector[0, 2, 2, 4, 4, 5]
当前index [0, 1, 2, 3, 4, 5]
从节点3出发，vector[3]=4, vector[4]=4,于是找到节点3所在集合的代表节点为4
从节点2出发，vector[2]=2, 找到节点2所在集合的代表节点为2
于是，将4的代表置为2，vector[4]=2, vector[2]=2
对应的vector[0, 2, 2, 4, 2, 5]
对应的index [0, 1, 2, 3, 4, 5]
集合变化如下图：


##########################################################################

#### 4.读取[1, 4]
读取顺序为[[1,2], [3,4], [3,2], [1,4], [1,5]]
</br>当前vector[0, 2, 2, 4, 2, 5]
</br>当前index [0, 1, 2, 3, 4, 5]
</br>从节点1出发，vector[1]=2, vector[2]=2, 找到节点1所在集合代表节点为2
</br>从节点4出发，vector[4]=2, vector[2]=2, 找到节点4所在集合代表节点为2
</br>由于1和4的代表节点相同，说明这两个节点本身就在同一个集合中
</br>由于原图是无向图，路径是双向可达的，1能够到达2,而且2能够到达4，再加上1能够到达4
</br>说明1能通过两条路径到达4，,这也意味着这条边出现的时候，原图中一定出现了环
</br>至于题中要求的，返回最后一条边，其实这就是返回添加过后会构成环的那一条边
</br>直白解释就是，在这条边出现之前，图中没有环
这条边出现，图中也出现环。包括这条边在内，构成环的边都是满足破圈条件的边
</br>然而谁是最后一条出现在边集合里的？当然，就是这条构成环的最后一条边
##########################################################################
