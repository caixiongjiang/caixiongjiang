## 数组中涉及的常见算法
1. 数组元素的赋值(杨辉三角、回形数等)
2. 求数值型数组中元素的最大值、最小值、平均数、总和等
3. 数组的复制、反转、查找(线性查找、二分法查找)
4. 数组元素的排序算法

### 数组元素的赋值

#### 【拓展之笔试题】创建一个长度为6的int型数组，要求数组元素的值都在1-30之间，且是随机赋值。同时，要求元素的值各不相同。

</br>方式一(使用标记)：

```java
/*
 * 
 * 【拓展之笔试题】创建一个长度为6的int型数组，要求数组元素的值都在1-30之间，且是随机赋值。同时，要求元素的值各不相同。
 * 
 * 
 * 
 * */
public class ArrayExer2 {
	public static void main(String[] args) {
		int[] arr=new int[6];
		for(int i=0;i<arr.length;i++) {
			arr[i]=(int)(Math.random()*30)+1;
			
			boolean flag=false;
			while(true){
				for(int j=0;j<i;j++) {
					if(arr[i]==arr[j]){
						flag=true;
						break;
					}
				}
				if(flag) {
					arr[i]=(int)(Math.random()*30)+1;
					flag=false;
					continue;
				}
				break;
			}
		}
		for(int i=0;i<arr.length;i++) {
			System.out.print(arr[i]+" ");
		}
	}
}
```
</br>方式二：

```java
public class ArrayExer2 {
	public static void main(String[] args) {
		int[] arr=new int[6];
		for(int i=0;i<arr.length;i++) {
			arr[i]=(int)(Math.random()*30)+1;
			
				for(int j=0;j<i;j++) {
					if(arr[i]==arr[j]){
						i--;
						break;
					}
				}
		}
		for(int i=0;i<arr.length;i++) {
			System.out.print(arr[i]+" ");
		}
	}
}
```

#### 螺旋矩阵(回形数组)

代码如下，已经详细注释了每一步的目的，可以看出while循环里判断的情况是很多的，代码里处理的原则也是统一的***左闭右开***。
```java
class Solution {
    public int[][] generateMatrix(int n) {
        int[][] res=new int[n][n];  // 定义一个二维数组
        int startx = 0, starty = 0; // 定义每循环一个圈的起始位置
        int loop = n / 2; // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理
        int mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)
        int count = 1; // 用来给矩阵中每一个空格赋值
        int offset = 1; // 每一圈循环，需要控制每一条边遍历的长度
        int i,j;
        while (loop -->0) {
            i = startx;
            j = starty;

            // 下面开始的四个for就是模拟转了一圈
            // 模拟填充上行从左到右(左闭右开)
            for (j = starty; j < starty + n - offset; j++) {
                res[startx][j] = count++;
            }
            // 模拟填充右列从上到下(左闭右开)
            for (i = startx; i < startx + n - offset; i++) {
                res[i][j] = count++;
            }
            // 模拟填充下行从右到左(左闭右开)
            for (; j > starty; j--) {
                res[i][j] = count++;
            }
            // 模拟填充左列从下到上(左闭右开)
            for (; i > startx; i--) {
                res[i][j] = count++;
            }

            // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)
            startx++;
            starty++;

            // offset 控制每一圈里每一条边遍历的长度
            offset += 2;
        }

        // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值
        if (n % 2==1) {
            res[mid][mid] = count;
        }
        return res;
    }
}
```

### 求数值型数组中元素的最大值、最小值、平均数、总和等

```java
/*
 * 算法：求数值型数组中元素的最大值、最小值、平均数、总和等
 * 
 * 
 * 定义一个int型的一维数组，包含10个元素，分别赋一些随机整数，然后求出所有元素的最大值，最小值，和值，平均值，并输出出来。
 * 要求：所有随机数都是两位数。
 * 
 * Math.random() :[0.0,1)
 * 
 * Math.random()*90:[0.0,90.0)
 * (int)(Math.random()*90):[0,89]
 * (int)(Math.random()*90+10):[10,99]
 * 
 * 获取[a,b]范围的随机数：(int)(Math.random()*(b-a+1))+a
 * 
 * [10,99]
 * 公式：(int)(Math.random() *(99-10+1)+10)
 * 
 */
public class ArrayExer3 {
	public static void main(String[] args) {
		int[] arr=new int[10];
		
		for(int i=0;i<arr.length;i++) {
			arr[i]=(int)(Math.random() *(99-10+1)+10);//[10,99]
		}
		//求最大值
		int maxValue=arr[0];
		for(int i=1;i<arr.length;i++) {
			if(maxValue<arr[i]) {
				maxValue=arr[i];
			}
		}
		System.out.println("最大值为"+maxValue);
		//求最小值
		//求平均数
		//求总和
	}
}
```

### 数组的整体赋值和复制
看如下代码：

```java
	int[] array1, array2;
	array1 = new int[] { 2, 3, 5, 7, 11, 13, 17, 19 };
	array2 = array1;//相当于电脑中给array1添加一个快捷方式，所以不能叫做数组的复制
	for (int i = 0; i < array2.length; i++) {
		if (i % 2 == 0) {
			array2[i] = i;
		}
	}
```
其代码的内存解析：栈中有两个数组索引array1和array2，索引的地址都指向队中的同一个数组的空间。
</br><span style="color:green">*也就是说，只有new了一个数组才会在堆中开辟空间存放数组元素。*</span>

</br></br>那么，如何实现数组的复制呢？
对上述代码做一定的修改：

```java
	int[] array1, array2;
	array1 = new int[] { 2, 3, 5, 7, 11, 13, 17, 19 };
	//数组的复制：
	array2 = new int[array1.length];
	for(int i=0;i<array2.length;i++){
		array2[i]=array1[i];
	}
	for (int i = 0; i < array2.length; i++) {
		if (i % 2 == 0) {
			array2[i] = i;
		}
	}
```
### 数组的查找(搜索)

```java
/*
 * 数组的反转，查找
 * 
 * 
 * 
 * */

public class ArrayTest4 {
	public static void main(String[] args) {
		String[] arr=new String[] {"JJ","DD","MM","BB","GG","AA"};
		//数组的反转：
		//方法一：
		for(int i=0,j=arr.length-1;i<j;i++,j--) {
			String tmp =arr[i];
			arr[i]=arr[j];
			arr[j]=tmp;
		}
		//方法二：
//		for(int i=0;i<arr.length/2;i++) {
//			String tmp =arr[i];
//			arr[i]=arr[arr.length-i-1];
//			arr[arr.length-i-1]=tmp;
//		}
		
		for(int i=0;i<arr.length;i++) {
			System.out.println(arr[i]);
		}
		//查找(或搜索)
		//线性查找：(略)
		//二分法查找：以找BB为例(左闭右开原则),适用于有序的数组
		int[] arr2=new int[]{-98,-34,2,34,54,66,79,105,210,333};
		int dest1=2;
		int start=0,end=arr2.length-1;//【start,end】
		boolean isFlag=true;
		while(start<end) {
			//int middle=(start+end)/2;
			int middle=start+((end-start)/2);//防止溢出，与上一句一样效果
			if(dest1==arr2[middle]) {
				System.out.println("位置为："+middle);
				isFlag=false;
				break;
			}else if(arr2[middle]>dest1) {
				end=middle-1;//【start,middle-1】
			}else {
				start=middle+1;//【middle+1,end】
			}
		}
		if(isFlag==true) {
			System.out.println("没有找到！");
		}
	}
}
```

### 数组的排序

<span style="color:red">衡量排序算法的优劣：</span>
</br>1.时间复杂度：分析关键字的比较次数和记录的移动次数
</br>2.空间复杂度：分析排序算法中需要多少辅助内存
</br>3.稳定性：若两个记录A和B的关键字值相等，但排序后A、B的先后次序保持不变，则称这种排序算法是稳定的。

排序算法分类：***内部排序***和***外部排序。***
* 内部排序：整个排序过程不需要借助于外部存储器（如磁盘等），所有排序操作都在内存中完成。
* 外部排序：参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助于外部存储器（如磁盘）。外部排序最常见的是多路归并排序。可以认为外部排序是由多次内部排序组成。
</br>

#### 十大内部排序算法：
* 选择排序（直接选择排序，<span style="color:yellow">堆排序</span>）
* 交换排序<span style="color:yellow">（冒泡排序，快速排序）</span>
* 插入排序（直接插入，折半插入，希尔排序）
* 归并排序
* 桶式排序
* 基数排序
java实现详见[数据结构与算法——java实现]()